
## 1. 데이터 로딩 전략

### 1.1 지연 로딩 (Lazy Loading)

- **정의**: 엔티티의 연관된 데이터를 실제로 사용할 때까지 데이터베이스에서 가져오지 않고 필요할 때 가져오는 방식
- **장점**: 초기 로딩 시 불필요한 데이터베이스 접근을 줄여 성능을 최적화할 수 있음
- **단점**: 연관된 엔티티를 사용할 때마다 추가적인 쿼리가 발생할 수 있어 N+1 문제를 일으킬 수 있음
- **사용 시나리오**: 대량의 데이터를 다루는 경우나 연관 관계가 복잡한 경우에 유용

### 1.2 즉시 로딩 (Eager Loading)

- **정의**: 엔티티를 조회할 때 연관된 엔티티를 즉시 함께 로딩하는 방식
- **장점**: 연관된 엔티티를 사용할 때 추가적인 데이터베이스 접근이 필요하지 않음
- **단점**: 불필요한 데이터까지 미리 로딩하기 때문에 메모리 사용량이 증가하고 성능에 영향을 줄 수 있음
- **사용 시나리오**: 항상 함께 사용되는 연관 관계에 적합

## 2. 영속성 관리

### 2.1 더티 체킹 (Dirty Checking)

- **정의**: 엔티티의 상태가 변경되었을 때 트랜잭션이 커밋될 때 자동으로 변경 사항을 데이터베이스에 반영하는 기능
- **작동 방식**: 영속성 컨텍스트는 엔티티의 원본 상태를 저장하고 엔티티의 현재 상태와 비교하여 변경 사항이 있는 경우 자동으로 UPDATE 쿼리를 생성
- **장점**: 개발자가 명시적으로 update 메서드를 호출하지 않아도 되어 편리함

### 2.2 1차 캐시

- **정의**: 영속성 컨텍스트 내에서 엔티티를 조회하거나 저장할 때 해당 엔티티를 캐시하여 동일한 트랜잭션 내에서 데이터베이스에 반복적으로 접근하는 것을 방지하는 기능
- **장점**: 동일한 엔티티에 대한 중복된 데이터베이스 접근을 줄여 성능을 최적화
- **단점**: 큰 트랜잭션에서 메모리 사용량이 증가할 수 있음

### 2.3 영속성 컨텍스트

- **정의**: 엔티티 매니저가 관리하는 엔티티 객체들이 저장되는 공간
- **역할**:
    1. 엔티티를 영속성 컨텍스트에 저장하여 1차 캐시를 제공
    2. 엔티티의 변경 감지를 통해 더티 체킹을 수행
    3. 트랜잭션이 끝날 때 변경 사항을 데이터베이스에 반영
- **장점**: 엔티티의 생명주기를 효율적으로 관리하여 데이터베이스 작업을 최적화

## 3. 연관 관계

### 3.1 1대N 연관관계

- **정의**: 한 엔티티가 여러 엔티티와 연관된 관계
- **예시**: Order와 OrderItem 관계에서 한 Order가 여러 OrderItem을 가질 수 있음

### 3.2 N대1 연관관계

- **정의**: 여러 엔티티가 하나의 엔티티와 연관된 관계
- **예시**: 여러 OrderItem이 하나의 Order에 속할 수 있음

### 3.3 N대N 연관관계

- **정의**: 여러 엔티티가 여러 엔티티와 연관된 관계
- **예시**: Student와 Course 사이의 관계는 다대다 관계
- **주의사항**: 실제 구현 시 중간 테이블을 사용하여 두 개의 1대N 관계로 구현하는 것이 일반적

### 3.4 1대1 연관관계

- **정의**: 한 엔티티가 다른 한 엔티티와 연관된 관계
- **예시**: User와 Profile 사이의 관계는 일대일 관계

## 4. 성능 최적화 기법

### 4.1 페치 조인 (Fetch Join)

- **정의**: 연관된 엔티티를 함께 조회하기 위해 사용하는 조인 방식
- **장점**: 한 번의 쿼리로 여러 연관된 엔티티를 함께 로드할 수 있어 N+1 문제를 방지
- **단점**: 너무 많은 연관 엔티티를 페치 조인하면 데이터 중복과 성능 저하를 일으킬 수 있음
- **사용 시나리오**: 특정 엔티티와 그 연관 엔티티를 자주 함께 조회하는 경우

### 4.2 N+1 문제

- **정의**: 하나의 쿼리로 N개의 엔티티를 조회하고 각 엔티티에 연관된 데이터를 가져오기 위해 추가로 N번의 쿼리가 실행되는 상황
- **해결 방법**:
    1. 페치 조인 사용
    2. 배치 사이즈 설정
    3. EntityGraph 사용
    4. DTO로 직접 조회

### 4.3 Batch Fetching

- **정의**: 한 번의 쿼리로 여러 연관된 엔티티를 일괄로 가져오는 방식
- **사용 이유**: 지연 로딩과 함께 사용하여 N+1 문제를 완화하기 위해 사용
- **설정 방법**: @BatchSize 어노테이션 또는 hibernate.default_batch_fetch_size 속성 사용

## 5. 추가 개념

### 5.1 영속성 전이 (Cascade)

- **정의**: 엔티티의 상태 변화가 연관된 다른 엔티티에도 전이되도록 하는 기능
- **예시**: 부모 엔티티를 삭제할 때 자식 엔티티도 함께 삭제하는 경우 CascadeType.ALL 설정
- **주의사항**: 남용 시 예상치 못한 부작용이 발생할 수 있으므로 신중하게 사용해야 함

### 5.2 고아 객체 (Orphan Removal)

- **정의**: 부모 엔티티에서 제거된 자식 엔티티를 자동으로 삭제하는 기능
- **예시**: 부모 엔티티에서 자식 엔티티를 제거하면 자식 엔티티도 삭제되도록 orphanRemoval = true 설정
- **사용 시나리오**: 부모-자식 관계에서 자식의 생명주기가 부모에 완전히 종속적인 경우

### 5.3 식별자 생성 전략 (GenerationType)

- **정의**: 데이터베이스에서 기본 키를 생성하는 방법을 지정하는 전략
- **종류**: AUTO, IDENTITY, SEQUENCE, TABLE
- **선택 기준**: 데이터베이스의 특성과 애플리케이션의 요구사항에 따라 선택

### 5.4 JPQL (Java Persistence Query Language)

- **정의**: JPA에서 사용하는 객체지향 쿼리 언어로 데이터베이스의 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성
- **특징**: SQL과 유사하지만 엔티티 객체를 대상으로 쿼리하므로 더 객체지향적임
- **장점**: 데이터베이스에 독립적인 쿼리 작성 가능

### 5.5 엔티티 생명주기 (Entity Life Cycle)

- **정의**: 엔티티가 영속성 컨텍스트에서 가지는 상태 변화 과정을 의미
- **상태**:
    1. Transient (비영속): 데이터베이스와 연결되지 않은 상태
    2. Persistent (영속): 영속성 컨텍스트에 의해 관리되는 상태
    3. Detached (준영속): 영속성 컨텍스트에서 분리된 상태
    4. Removed (삭제): 데이터베이스에서 삭제된 상태

### 5.6 Locking Mechanisms

- **정의**: 동시에 여러 트랜잭션이 같은 데이터를 수정하지 못하게 하는 동시성 제어 메커니즘
- **종류**:
    1. Optimistic Locking: 데이터가 변경되지 않았다고 가정하고 트랜잭션 커밋 시점에 충돌을 감지
    2. Pessimistic Locking: 데이터에 대한 수정이 발생하지 않도록 잠금을 걸어 다른 트랜잭션이 수정하지 못하도록 함
- **선택 기준**: 애플리케이션의 동시성 요구사항과 성능 고려사항에 따라 선택