
# JPA (Java Persistence API) 개요

## 1. JPA의 필요성

### 1.1 현재 개발 환경과 문제점
- **자바**는 주로 **객체지향**을 활용하지만, **DB**는 여전히 **RDBMS**가 주류(de facto)입니다.
- 이로 인해 객체와 RDBMS 간의 **불일치** 문제를 해결해야 합니다.

### 1.2 SQL 중심 개발의 문제점
1. **반복적 코드**: 
   - CRUD 쿼리를 직접 작성해야 하며, Java 객체와 SQL 간의 변환 작업이 필요합니다.
   - 테이블 변경 시 많은 SQL 문을 수정해야 합니다.

2. **패러다임의 불일치**:
   - 객체지향과 관계형 데이터베이스 간의 **사상 차이**가 존재합니다.
   - 객체는 상속, 다형성 등을 활용하지만, RDBMS는 데이터를 정교하게 구조화하는 것이 목표입니다.

3. **객체와 RDBMS의 차이**:
   - RDBMS에는 **상속 개념**이 없으며, 객체지향의 캡슐화, 정보은닉과 같은 개념이 없습니다.
   - 조인을 통해 데이터를 연결해야 하며, 이로 인해 매핑 작업이 증가합니다.

### 1.3 JPA의 필요성
- 객체를 **자바 컬렉션에 저장하듯** RDBMS에 저장할 수 있도록 하는 것이 JPA의 목표입니다.

## 2. JPA 소개

### 2.1 ORM(Object-Relational Mapping)
- **ORM**은 객체와 DB를 각각 설계한 후, **매핑**을 통해 객체와 DB 간의 불일치 문제를 해결하는 기술입니다.
- 개발자는 직접 JDBC API를 사용하지 않고, JPA를 통해 ORM 프레임워크가 자동으로 SQL 쿼리를 생성하고 실행합니다.

### 2.2 JPA 표준 명세와 구현체
- **JPA**는 **인터페이스의 모음**입니다.
- 현재 JPA 2.1 표준 명세를 구현한 3가지 주요 구현체가 있으며, 그 중 **Hibernate**가 가장 널리 사용됩니다.

### 2.3 JPA의 장점
1. **객체 중심 개발**: SQL 중심의 개발에서 벗어나 객체 중심의 개발이 가능합니다.
2. **생산성 향상**: SQL을 직접 작성하는 것보다 더 간결하고 효율적입니다.
3. **유지보수성 향상**: 필드 변경 시, SQL 쿼리 수정 없이도 JPA가 자동으로 처리해줍니다.

## 3. 영속성 컨텍스트

### 3.1 JPA의 핵심 개념
- **객체와 관계형 DB의 매핑**과 **영속성 컨텍스트**는 JPA에서 가장 중요한 두 가지 개념입니다.

### 3.2 EntityManager와 EntityManagerFactory
- **EntityManagerFactory**: 애플리케이션 실행 시 한 번 생성되며, 다수의 `EntityManager` 인스턴스를 생성하는 팩토리입니다.
- **EntityManager**: 각 요청마다 생성되며, DB와의 커넥션을 통해 작업을 처리하고 엔티티를 영속성 컨텍스트에서 관리합니다.

### 3.3 영속성 컨텍스트란?
- **영속성 컨텍스트**는 "엔티티를 일시적으로 관리/저장하는 환경"을 의미하는 JPA의 핵심 개념입니다.
- 엔티티가 영속성 컨텍스트에 저장된 상태를 "영속 상태"라고 합니다.
- `EntityManager.persist(entity)`를 호출하면, 엔티티는 **영속성 컨텍스트**에 저장됩니다.
- 영속성 컨텍스트는 **논리적인 개념**이며, 눈에 보이지 않는 **캐시**로 생각할 수 있습니다.

### 3.4 1차 캐시
- 영속성 컨텍스트에는 **1차 캐시**라는 메커니즘이 있습니다. 
- 엔티티가 영속성 컨텍스트에 저장되면, JPA는 이 엔티티를 1차 캐시에 저장합니다.
- **1차 캐시의 장점**:
  - **성능 최적화**: 동일한 엔티티를 반복해서 조회할 때, DB에 불필요한 쿼리를 보내지 않습니다.
  - **트랜잭션 범위 내의 동일성 보장**: 같은 트랜잭션 안에서는 동일한 엔티티가 항상 동일한 인스턴스로 조회됩니다.

```java
// EntityManager 생성 및 트랜잭션 시작
EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

// 비영속 상태의 Member 엔티티 생성
Member member = new Member();
member.setId(1L);
member.setName("John Doe");

// 영속 상태로 전환 (1차 캐시에 저장)
em.persist(member);

// 1차 캐시에서 조회
Member findMember = em.find(Member.class, 1L);

// 트랜잭션 커밋 (실제로 DB에 반영)
em.getTransaction().commit();
em.close(); // EntityManager 닫기
```

### 3.5 엔티티의 생명주기
1. **비영속 (Transient)**:
   - 엔티티가 **영속성 컨텍스트와 전혀 연관되지 않은 상태**입니다.
   ```java
   Member member = new Member(); // 비영속 상태
   member.setId(1L);
   member.setName("John Doe");
   ```

2. **영속 (Persistent)**:
   - 엔티티가 **영속성 컨텍스트에 저장된 상태**를 말합니다.
   ```java
   em.persist(member); // 영속 상태
   ```

3. **준영속 (Detached)**:
   - 엔티티가 **영속성 컨텍스트에서 분리된 상태**입니다.
   ```java
   em.detach(member); // 준영속 상태
   ```

4. **삭제 (Removed)**:
   - 엔티티가 **삭제된 상태**입니다.
   ```java
   em.remove(member); // 삭제 상태
   ```

### 3.6 영속성 컨텍스트의 주요 장점
1. **1차 캐시**: 동일한 트랜잭션 안에서 동일한 엔티티를 조회할 때, DB 조회 없이 1차 캐시에서 데이터를 가져옵니다.

2. **트랜잭션을 통한 변경 감지 (Dirty Checking)**: 엔티티의 상태가 변경되면, JPA는 트랜잭션이 커밋되는 시점에 변경된 내용을 자동으로 감지하고, SQL을 생성하여 DB에 반영합니다.

	작동 원리
	
	1. **스냅샷 저장**:
	   - 엔티티가 영속성 컨텍스트에 처음 저장될 때, JPA는 해당 엔티티의 최초 상태를 스냅샷으로 저장합니다.
	
	2. **변경 감지 수행**:
	   - 트랜잭션이 커밋되는 시점에 JPA는 flush()를 호출합니다.
	   - flush() 메서드는 영속성 컨텍스트의 모든 엔티티를 검사합니다.
	   - 각 엔티티의 현재 상태를 최초의 스냅샷과 비교합니다.
	
	3. **변경 사항 확인**:
	   - 스냅샷과 현재 상태가 다르다면, 해당 엔티티는 '변경되었다(Dirty)'고 판단됩니다.
	
	4. **UPDATE 쿼리 생성 및 실행**:
	   - 변경된 엔티티에 대해 UPDATE 쿼리를 생성합니다.
	   - 이 쿼리는 쓰기 지연 SQL 저장소에 저장됩니다.
	   - 트랜잭션이 커밋될 때 이 쿼리들이 데이터베이스로 전송되어 실행됩니다.

	### 예시 코드
	
	```java
	EntityManager em = emf.createEntityManager();
	EntityTransaction transaction = em.getTransaction();
	
	try {
	    transaction.begin();  // 트랜잭션 시작
	
	    // 엔티티 조회
	    Member member = em.find(Member.class, 1L);
	
	    // 엔티티 데이터 변경
	    member.setName("New Name");
	    
	    // 명시적인 em.update(member) 호출이 없음!
	
	    transaction.commit();  // 트랜잭션 커밋
	} catch (Exception e) {
	    transaction.rollback();
	} finally {
	    em.close();
	}
	```
	
	이 코드에서 `member.setName("New Name")`만으로 변경 사항이 데이터베이스에 반영됩니다. 명시적인 update 메서드 호출이 필요 없습니다.

	주의사항
	
	1. **영속 상태의 엔티티에만 적용**: 변경 감지는 영속성 컨텍스트가 관리하는 엔티티에만 적용됩니다.
	
	2. **트랜잭션 범위**: 변경 감지는 트랜잭션 안에서만 동작합니다.
	
	3. **성능 고려**: 변경 감지는 영속성 컨텍스트가 관리하는 모든 엔티티를 검사하므로, 관리하는 엔티티가 많을 경우 성능에 영향을 줄 수 있습니다.
	
	4. **부분 업데이트**: 기본적으로 모든 필드를 업데이트하는 쿼리를 생성하지만, @DynamicUpdate 어노테이션을 사용하여 변경된 필드만 업데이트하도록 최적화할 수 있습니다.
	
	변경 감지 기능은 JPA의 강력한 특징 중 하나로, 개발자가 명시적으로 업데이트 로직을 작성하지 않아도 되게 해주어 생산성을 크게 향상시킵니다. 그러나 이 기능의 동작 원리를 이해하고 적절히 사용하는 것이 중요합니다.

3. **쓰기 지연 (Write-behind)**: 여러 SQL 쿼리를 모아서 트랜잭션이 커밋되는 시점에 한꺼번에 실행하여 성능을 최적화합니다.

4. **엔티티의 동일성 보장**: 동일한 트랜잭션 내에서 동일한 ID를 가진 엔티티는 항상 동일한 객체로 보장됩니다.

# 추가 설명
## 1. 데이터 로딩 전략

### 1.1 지연 로딩 (Lazy Loading)

- **정의**: 엔티티의 연관된 데이터를 실제로 사용할 때까지 데이터베이스에서 가져오지 않고 필요할 때 가져오는 방식
- **장점**: 초기 로딩 시 불필요한 데이터베이스 접근을 줄여 성능을 최적화할 수 있음
- **단점**: 연관된 엔티티를 사용할 때마다 추가적인 쿼리가 발생할 수 있어 N+1 문제를 일으킬 수 있음
- **사용 시나리오**: 대량의 데이터를 다루는 경우나 연관 관계가 복잡한 경우에 유용

### 1.2 즉시 로딩 (Eager Loading)

- **정의**: 엔티티를 조회할 때 연관된 엔티티를 즉시 함께 로딩하는 방식
- **장점**: 연관된 엔티티를 사용할 때 추가적인 데이터베이스 접근이 필요하지 않음
- **단점**: 불필요한 데이터까지 미리 로딩하기 때문에 메모리 사용량이 증가하고 성능에 영향을 줄 수 있음
- **사용 시나리오**: 항상 함께 사용되는 연관 관계에 적합

### 1. JPA 로딩 전략 및 N+1 문제 발생 여부

| 로딩 전략     | 단일 값 연관 관계 (Many-to-One, One-to-One) | 컬렉션 타입 연관 관계 (One-to-Many, Many-to-Many) | N+1 문제 발생 여부      |
| --------- | ------------------------------------ | ---------------------------------------- | ----------------- |
| **지연 로딩** | 기본적으로 해당 엔티티가 참조될 때까지 로딩되지 않음        | 컬렉션의 개별 요소에 접근할 때마다 쿼리 발생                | 발생 가능             |
| **즉시 로딩** | 엔티티 조회 시 즉시 로딩                       | 부모 엔티티 조회 시 컬렉션도 함께 로딩하려고 시도             | 발생 가능 (상황에 따라 다름) |

### 2. 즉시 로딩에서 컬렉션 타입의 N+1 문제 발생 여부

|조건|발생 여부|설명|
|---|---|---|
|**즉시 로딩 + 단일 값 연관 관계**|**발생 안함**|단일 값 연관 관계 (예: `@ManyToOne`, `@OneToOne`)에서는 즉시 로딩 시 한 번의 조인 쿼리로 데이터를 가져옵니다.|
|**즉시 로딩 + 컬렉션 타입 (One-to-Many, Many-to-Many)**|**상황에 따라 발생**|즉시 로딩이더라도, JPA는 컬렉션 타입을 효율적으로 한 번에 로딩하지 못할 경우 N+1 문제가 발생할 수 있습니다.|

### 3. 컬렉션 타입에서 즉시 로딩의 N+1 문제 발생 예시

| 상황                                           | 쿼리 실행 횟수 예시                        | N+1 문제 발생 여부 |
| -------------------------------------------- | ---------------------------------- | ------------ |
| **Order 엔티티 10개 조회 + OrderItem 컬렉션 (즉시 로딩)** | 1번 `Order` 쿼리 + 10번 `OrderItem` 쿼리 | 발생           |
| **Order 엔티티 10개 조회 + OrderItem 컬렉션 (페치 조인)** | 1번 `Order` + `OrderItem` 조인 쿼리 1번  | 발생 안함        |
| **Order 엔티티 1개 조회 + OrderItem 컬렉션 (즉시 로딩)**  | 1번 `Order` + 1번 `OrderItem` 쿼리     | 발생 안함        |

### 결론

- **즉시 로딩**을 사용하더라도 컬렉션 타입의 연관 관계에서 항상 N+1 문제가 발생하는 것은 아닙니다. 하지만, 많은 부모 엔티티를 한 번에 조회하는 상황에서 컬렉션을 즉시 로딩할 경우, JPA가 각 컬렉션 항목을 별도의 쿼리로 가져오게 되면서 N+1 문제가 발생할 수 있습니다.
- **단일 값 연관 관계**에서는 즉시 로딩이 N+1 문제를 유발하지 않습니다. 이는 한 번의 조인 쿼리로 필요한 모든 데이터를 가져올 수 있기 때문입니다.
- **페치 조인**을 사용하면 이러한 문제를 방지하고, 한 번의 쿼리로 모든 관련 데이터를 효율적으로 가져올 수 있습니다.


## 2. 영속성 관리

### 2.1 더티 체킹 (Dirty Checking)

- **정의**: 엔티티의 상태가 변경되었을 때 트랜잭션이 커밋될 때 자동으로 변경 사항을 데이터베이스에 반영하는 기능
- **작동 방식**: 영속성 컨텍스트는 엔티티의 원본 상태를 저장하고 엔티티의 현재 상태와 비교하여 변경 사항이 있는 경우 자동으로 UPDATE 쿼리를 생성
- **장점**: 개발자가 명시적으로 update 메서드를 호출하지 않아도 되어 편리함

### 2.2 1차 캐시

- **정의**: 영속성 컨텍스트 내에서 엔티티를 조회하거나 저장할 때 해당 엔티티를 캐시하여 동일한 트랜잭션 내에서 데이터베이스에 반복적으로 접근하는 것을 방지하는 기능
- **장점**: 동일한 엔티티에 대한 중복된 데이터베이스 접근을 줄여 성능을 최적화
- **단점**: 큰 트랜잭션에서 메모리 사용량이 증가할 수 있음

### 2.3 영속성 컨텍스트

- **정의**: 엔티티 매니저가 관리하는 엔티티 객체들이 저장되는 공간
- **역할**:
    1. 엔티티를 영속성 컨텍스트에 저장하여 1차 캐시를 제공
    2. 엔티티의 변경 감지를 통해 더티 체킹을 수행
    3. 트랜잭션이 끝날 때 변경 사항을 데이터베이스에 반영
- **장점**: 엔티티의 생명주기를 효율적으로 관리하여 데이터베이스 작업을 최적화

## 3. 연관 관계

### 3.1 1대N 연관관계

- **정의**: 한 엔티티가 여러 엔티티와 연관된 관계
- **예시**: Order와 OrderItem 관계에서 한 Order가 여러 OrderItem을 가질 수 있음

### 3.2 N대1 연관관계

- **정의**: 여러 엔티티가 하나의 엔티티와 연관된 관계
- **예시**: 여러 OrderItem이 하나의 Order에 속할 수 있음

### 3.3 N대N 연관관계

- **정의**: 여러 엔티티가 여러 엔티티와 연관된 관계
- **예시**: Student와 Course 사이의 관계는 다대다 관계
- **주의사항**: 실제 구현 시 중간 테이블을 사용하여 두 개의 1대N 관계로 구현하는 것이 일반적

### 3.4 1대1 연관관계

- **정의**: 한 엔티티가 다른 한 엔티티와 연관된 관계
- **예시**: User와 Profile 사이의 관계는 일대일 관계


### 3.5.1 양방향 예시 (1:N, N:1)

``` JAVA
@Entity
public class Team {

  

    @Id @GeneratedValue
    private Long id;

  

    private String name;

  

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();

}

  

@Entity
public class Member {

  

    @Id @GeneratedValue

    private Long id;

  

    private String name;

  

    @ManyToOne
    @JoinColumn(name = "team_id") // N:1 쪽에서 외래 키 관리
    private Team team;

}
```

**Member** **엔티티**:
	• @ManyToOne 관계를 사용하여 Team 엔티티와의 N:1 관계를 정의했습니다.
	• 이 설정은 Member 엔티티가 외래 키(team_id)를 통해 Team 엔티티를 참조하도록 만듭니다.

**Team** **엔티티**:
	• @OneToMany(mappedBy = "team")를 사용하여 Member 엔티티와의 1:N 관계를 정의했습니다.
	• mappedBy = "team"는 이 관계가 Member 엔티티의 team 필드에 의해 매핑된다는 것을 의미합니다. 
	• 즉, Team 엔티티는 members 리스트를 통해 자신에게 속한 Member들을 참조할 수 있습니다.

  
**양방향 관계의 정의**
	양방향 연관 관계란 **두 엔티티가 서로를 참조할 수 있는 관계**를 의미합니다. 

• Member 엔티티에서 Team을 참조할 수 있습니다.
• Team 엔티티에서 members 리스트를 통해 여러 Member들을 참조할 수 있습니다.

따라서, 이 예제는 양방향 관계로 설정된 것입니다.

  

**mappedBy의 역할**

• **mappedBy**는 JPA에서 양방향 관계를 설정할 때 사용됩니다. 이 속성은 **양방향 관계에서 외래 키를 관리하는 주체가 어느 쪽인지를 명시**하는 역할을 합니다.

• mappedBy = "team"을 Team 엔티티의 members 필드에 설정함으로써, 이 연관 관계의 주체(외래 키를 관리하는 주체)는 Member 엔티티의 team 필드임을 나타냅니다.

• 따라서, @OneToMany 쪽에서는 외래 키를 직접 관리하지 않고, **외래 키는** **Member** **엔티티 쪽에서 관리**됩니다.

  

**결론**

• **양방향 관계**: 두 엔티티(Team과 Member)가 서로를 참조할 수 있기 때문에, 이 예제는 양방향 연관 관계로 설정된 것입니다.

• **mappedBy****의 의미**: Team 엔티티 쪽에서 mappedBy를 사용함으로써, 외래 키 관리의 주체가 Member 엔티티 쪽에 있음을 명시했지만, 여전히 두 엔티티는 서로를 참조할 수 있으므로 양방향 관계로 간주됩니다.


### 3.5.2 단방향으로 변경 (N:1)

어떤 유튜버의 연관관계 사용 지침 (절대적인 정답이 아님을 주의)
	https://www.youtube.com/watch?v=vgNHW_nb2mg&t=2s
	
	걸지 않는 경우
	- ﻿﻿양방향
	- ﻿﻿단방향도 OneToMany 잘 안건다
	- ﻿﻿OneToOne 안건다
	
	거는 지침
	- ﻿﻿라이프사이클(생명주기) 가 완전히 같다면 단방향만 ' 고민 ' 합니다
	- ﻿﻿고민 후 단방향 ManyToOne 을 보통 건다
	
	상당히 심오한 주제였음... 어둠의 다크니스

이를 반영해본다면 ?

```JAVA

@Entity
public class Team {

    @Id @GeneratedValue
    private Long id;

    private String name;

    // @OneToMany 제거: 단방향 관계로 변경하므로 이 부분을 제거합니다.
    // private List<Member> members = new ArrayList<>();
}

@Entity
public class Member {

    @Id @GeneratedValue
    private Long id;

    private String name;

    @ManyToOne
    @JoinColumn(name = "team_id") // 단방향 ManyToOne 관계로 유지
    private Team team;
}
```

더 나아가서 어쩌면 team 이 아니라, team_id를 가질 수도 있다.
멤버가 팀이 없을 수도 있지 않을까?

**외래키를 직접 가지는 상황에 대한 질문과 좋은 답변**
https://www.inflearn.com/community/questions/747142/jpa-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A0%A8%ED%95%98%EC%97%AC-%EC%A7%88%EB%AC%B8-%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4

위 글에서 얻어야 하는 정보: 엔티티 관리보다 도메인이 우선이다. 도메인을 잘 설계해야한다.

1. **엔티티(Entity) → 도메인 모델(Domain Model)**:
	• 엔티티는 데이터베이스와의 상호작용을 담당하지만, 비즈니스 로직이 도메인 모델에서 구현되므로, 엔티티에서 도메인 모델로 변환이 이루어질 수 있습니다. 이 과정에서 엔티티의 데이터를 도메인 모델로 변환하거나, 도메인 모델이 엔티티를 참조하여 비즈니스 로직을 수행할 수 있습니다.

2. **도메인 모델(Domain Model) → DTO**:
	• 컨트롤러에서는 도메인 모델을 DTO로 변환하여 클라이언트로 전송합니다. 이 과정에서 DTO는 필요한 데이터만 포함하도록 설계되며, 도메인 모델의 복잡한 비즈니스 로직을 노출하지 않습니다.
	• 반대로, 클라이언트로부터 받은 데이터를 도메인 모델로 변환하여 비즈니스 로직을 수행하는 것도 중요합니다.


**양방향을 미워하는 이유**
양방향 매핑은 단순히 데이터베이스의 값을 조회하여 객체 그래프 탐색 기능이 추가된 것이다. 
**주인이 아닌 곳에서 엔티티를 추가해도 데이터베이스에는 절대 반영되지 않는다.**

또한 순수한 객체를 고려하여 양뱡향 매핑을 설정할 때는 엔티티를 통해 외래키를 추가하거나 수정하는 부분에서 주인이 아닌 엔티티까지 고려하여 처리해야 한다. -> 그래서 안쓰나보다. 귀찮아보이긴한다.

아래는 자세한 설명!
https://hyeonic.tistory.com/224



### 3.6 심화

1. **양방향 연관 관계를 피하는 이유**:

	• **복잡성 증가**: 양방향 연관 관계를 설정하면 양쪽의 데이터를 일관되게 유지하기 위해 많은 코드를 추가해야 합니다. 특히, 양방향 관계에서 관계를 업데이트할 때, 한쪽에서 변경된 내용을 다른 쪽에도 반영해야 하며, 이러한 과정에서 실수나 버그가 발생할 가능성이 높아집니다. 아래 설명에서도 나오겠지만, 외래키를 가지지 않은 측에서 변경한 데이터는 결과적으로 반영되지 않는다는 문제가 있음. (추가적인 로직으로 반영 가능하긴 함)
	
	• **N+1 문제**: 양방향 관계를 설정하면, 잘못된 쿼리 설계로 인해 N+1 문제가 발생할 가능성이 큽니다. 이는 성능 저하로 이어질 수 있습니다.
	
	• **테스트와 유지보수의 어려움**: 양방향 관계는 테스트 코드 작성과 유지보수를 복잡하게 만듭니다. 관계를 설정하고 유지하는 데 많은 리소스가 필요할 수 있습니다.

2. **단방향 연관 관계를 선호하는 이유**:

	• **단순성과 명료성**: 단방향 연관 관계는 설정이 단순하고 이해하기 쉽습니다. 한쪽에서만 관계를 관리하면 되므로, 코드가 직관적이고 복잡성이 줄어듭니다.
	
	• **효율적인 쿼리**: 단방향 관계는 쿼리를 작성할 때 더 명확하고 효율적인 SQL이 생성됩니다. 필요한 경우에만 데이터를 조회할 수 있으며, 불필요한 데이터 로딩을 방지할 수 있습니다.

3. **@OneToMany를 잘 사용하지 않는 이유**:

	• **비효율적인 데이터 접근**: 단방향 @OneToMany 관계에서는 데이터베이스에 외래 키가 설정되지 않기 때문에, JPA는 조인 테이블을 생성하거나, 컬렉션을 조회하기 위해 복잡한 쿼리를 생성하게 됩니다. 이는 성능 저하로 이어질 수 있습니다.
	
	• **데이터 무결성 유지의 어려움**: @OneToMany 관계를 제대로 관리하지 않으면, 데이터 무결성 문제를 야기할 수 있습니다. 특히, 관계를 업데이트할 때 일관성을 유지하는 것이 어려울 수 있습니다.

4. **@OneToOne을 피하는 이유**:

	• **낮은 효율성**: @OneToOne 관계는 실제로 데이터베이스 설계에서 자주 사용되지 않으며, 효율적이지 않은 경우가 많습니다. 양방향 @OneToOne 관계는 관리가 복잡할 수 있으며, 이를 유지하는 것이 비효율적일 수 있습니다.
	
	• **관계의 강제성**: @OneToOne 관계는 두 엔티티 간의 관계를 강하게 연결하며, 둘 중 하나라도 존재하지 않으면 관계가 성립되지 않습니다. 이는 설계의 유연성을 제한할 수 있습니다.

5. **@ManyToMany 관계를 잘 사용하지 않는 이유와 그 대안**

	**이유**
	
	1. **중간 테이블 관리의 어려움**
	
	• @ManyToMany 관계에서는 JPA가 **중간 테이블**을 자동으로 생성하여 관리합니다. 하지만 이 중간 테이블에 추가적인 정보를 저장하거나, 테이블 자체를 세밀하게 제어하기가 어렵습니다.
	
	• 예를 들어, Student와 Course 간의 다대다 관계를 표현하기 위해 자동 생성된 중간 테이블 Student_Course에 **등록 날짜**, **성적** 등의 추가 정보를 저장하고 싶을 때는 @ManyToMany로는 관리할 수 없습니다.
	
	2. **복잡한 쿼리 문제**
	
	• @ManyToMany 관계를 사용하면 복잡한 조인 쿼리가 자동으로 생성되며, 이는 데이터 양이 많아지면 성능 저하로 이어질 수 있습니다.
	
	• 특히, 이러한 쿼리를 최적화하고 관리하기 어려운 경우가 많아지므로, 대규모 애플리케이션에서는 부적합할 수 있습니다.
	
	3. **유지보수의 어려움**
	
	• 양방향 @ManyToMany 관계를 설정하면, 관계를 일관되게 관리해야 하며, 이로 인해 복잡성이 증가합니다.
	
	• 변경 사항을 양방향으로 반영해야 하며, 실수로 데이터 일관성이 깨질 가능성도 커집니다.
	
	• 또한, 잘못된 쿼리 설계로 인해 **N+1 문제**가 발생할 수 있어, 유지보수 및 디버깅이 어려워집니다.
	
	4. **데이터 무결성 관리의 복잡성**
	
	• @ManyToMany 관계에서는 중간 테이블을 자동으로 관리하므로, 데이터 무결성을 유지하기 어렵습니다.
	
	• 중간 테이블을 통한 데이터 조작이 필요할 때, @ManyToMany는 이러한 요구를 충분히 충족하지 못합니다.

	**대안**
	
	1. **중간 엔티티 도입 (****@OneToMany****와** **@ManyToOne** **사용)**
		@ManyToMany 대신 **중간 엔티티**를 도입하여 두 개의 @OneToMany와 @ManyToOne 관계로 풀어내는 방법이 많이 사용됩니다.
		혹은 **단방향 @ManyToOne**만으로 관계를 관리하여, 불필요한 복잡성을 줄이고, 데이터의 일관성을 유지하며, 실수를 방지하는 설계가 가능해집니다.
	
	``` java
		@Entity
	public class Student {
	    @Id
	    @GeneratedValue
	    private Long id;
	
	    private String name;
	
	    @OneToMany(mappedBy = "student")
	    private List<Enrollment> enrollments = new ArrayList<>();
	}
	
	@Entity
	public class Course {
	    @Id
	    @GeneratedValue
	    private Long id;
	
	    private String title;

		// OneToMany 는 위 설명처럼 생략도 가능하다. 읽기 전용이잖아~
	    // @OneToMany(mappedBy = "course")
	    // private List<Enrollment> enrollments = new ArrayList<>();
	}
	
	@Entity
	public class Enrollment {
	    @Id
	    @GeneratedValue
	    private Long id;
	
	    @ManyToOne
	    @JoinColumn(name = "student_id")
	    private Student student;
	
	    @ManyToOne
	    @JoinColumn(name = "course_id")
	    private Course course;
	
	    private LocalDateTime enrollmentDate;
	    private String grade;
	}```

6. **라이프사이클이 일치하는 경우에만 고민**:

	• **라이프사이클 동기화의 중요성**: 두 엔티티 간의 라이프사이클이 완전히 일치할 때만 연관 관계를 고려하는 이유는, 이를 통해 관계를 관리하는 복잡성을 줄일 수 있기 때문입니다. 예를 들어, 부모-자식 관계에서 부모가 삭제될 때 자식도 함께 삭제되도록 설정하는 경우가 이에 해당합니다.
	
	• **단방향** **@ManyToOne** **선호**: 라이프사이클이 일치하더라도, 단방향 @ManyToOne 관계를 사용하는 이유는 관계를 단순화하고, 성능 및 유지보수성을 높이기 위해서입니다.

  
**결론**

JPA의 연관 관계 설정에서 **복잡성, 성능 문제, 유지보수의 어려움**을 고려하여 연관 관계를 최대한 단순화하려는 접근 방식은 타당한 것 같습니다. 특히, **단방향 연관 관계**를 선호하고, **양방향 관계를 피하는 이유**는 관계를 단순하고 명확하게 유지하면서도, 성능과 유지보수성을 최적화할 수 있다고 생각합니다.

그러나, 특정 상황에서는 양방향 연관 관계나 @OneToMany, @OneToOne이 필요하거나 유용할 수도 있을 수 있으므로, 이러한 지침은 **상황에 맞게 유연하게 적용**하는 것이 중요합니다.


## 4. 성능 최적화 기법

### 4.1 페치 조인 (Fetch Join)

- **정의**: 연관된 엔티티를 함께 조회하기 위해 사용하는 조인 방식
- **장점**: 한 번의 쿼리로 여러 연관된 엔티티를 함께 로드할 수 있어 N+1 문제를 방지
- **단점**: 너무 많은 연관 엔티티를 페치 조인하면 데이터 중복과 성능 저하를 일으킬 수 있음
- **사용 시나리오**: 특정 엔티티와 그 연관 엔티티를 자주 함께 조회하는 경우

### 4.2 N+1 문제

- **정의**: 하나의 쿼리로 N개의 엔티티를 조회하고 각 엔티티에 연관된 데이터를 가져오기 위해 추가로 N번의 쿼리가 실행되는 상황
- **해결 방법**:
    1. 페치 조인 사용
    2. 배치 사이즈 설정
    3. EntityGraph 사용
    4. DTO로 직접 조회

### 4.3 Batch Fetching

- **정의**: 한 번의 쿼리로 여러 연관된 엔티티를 일괄로 가져오는 방식
- **사용 이유**: 지연 로딩과 함께 사용하여 N+1 문제를 완화하기 위해 사용
- **설정 방법**: @BatchSize 어노테이션 또는 hibernate.default_batch_fetch_size 속성 사용

## 5. 추가 개념

### 5.1 영속성 전이 (Cascade)

- **정의**: 엔티티의 상태 변화가 연관된 다른 엔티티에도 전이되도록 하는 기능
- **예시**: 부모 엔티티를 삭제할 때 자식 엔티티도 함께 삭제하는 경우 CascadeType.ALL 설정
- **주의사항**: 남용 시 예상치 못한 부작용이 발생할 수 있으므로 신중하게 사용해야 함

### 5.2 고아 객체 (Orphan Removal)

- **정의**: 부모 엔티티에서 제거된 자식 엔티티를 자동으로 삭제하는 기능
- **예시**: 부모 엔티티에서 자식 엔티티를 제거하면 자식 엔티티도 삭제되도록 orphanRemoval = true 설정
- **사용 시나리오**: 부모-자식 관계에서 자식의 생명주기가 부모에 완전히 종속적인 경우

### 5.3 식별자 생성 전략 (GenerationType)

- **정의**: 데이터베이스에서 기본 키를 생성하는 방법을 지정하는 전략
- **종류**: AUTO, IDENTITY, SEQUENCE, TABLE
- **선택 기준**: 데이터베이스의 특성과 애플리케이션의 요구사항에 따라 선택

### 5.4 JPQL (Java Persistence Query Language)

- **정의**: JPA에서 사용하는 객체지향 쿼리 언어로 데이터베이스의 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성
- **특징**: SQL과 유사하지만 엔티티 객체를 대상으로 쿼리하므로 더 객체지향적임
- **장점**: 데이터베이스에 독립적인 쿼리 작성 가능

### 5.5 엔티티 생명주기 (Entity Life Cycle)

- **정의**: 엔티티가 영속성 컨텍스트에서 가지는 상태 변화 과정을 의미
- **상태**:
    1. Transient (비영속): 데이터베이스와 연결되지 않은 상태
    2. Persistent (영속): 영속성 컨텍스트에 의해 관리되는 상태
    3. Detached (준영속): 영속성 컨텍스트에서 분리된 상태
    4. Removed (삭제): 데이터베이스에서 삭제된 상태

### 5.6 Locking Mechanisms

- **정의**: 동시에 여러 트랜잭션이 같은 데이터를 수정하지 못하게 하는 동시성 제어 메커니즘
- **종류**:
    1. Optimistic Locking: 데이터가 변경되지 않았다고 가정하고 트랜잭션 커밋 시점에 충돌을 감지
    2. Pessimistic Locking: 데이터에 대한 수정이 발생하지 않도록 잠금을 걸어 다른 트랜잭션이 수정하지 못하도록 함
- **선택 기준**: 애플리케이션의 동시성 요구사항과 성능 고려사항에 따라 선택