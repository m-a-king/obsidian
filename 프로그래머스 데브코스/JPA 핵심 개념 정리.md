
## 1. 데이터 로딩 전략

### 1.1 지연 로딩 (Lazy Loading)

- **정의**: 엔티티의 연관된 데이터를 실제로 사용할 때까지 데이터베이스에서 가져오지 않고 필요할 때 가져오는 방식
- **장점**: 초기 로딩 시 불필요한 데이터베이스 접근을 줄여 성능을 최적화할 수 있음
- **단점**: 연관된 엔티티를 사용할 때마다 추가적인 쿼리가 발생할 수 있어 N+1 문제를 일으킬 수 있음
- **사용 시나리오**: 대량의 데이터를 다루는 경우나 연관 관계가 복잡한 경우에 유용

### 1.2 즉시 로딩 (Eager Loading)

- **정의**: 엔티티를 조회할 때 연관된 엔티티를 즉시 함께 로딩하는 방식
- **장점**: 연관된 엔티티를 사용할 때 추가적인 데이터베이스 접근이 필요하지 않음
- **단점**: 불필요한 데이터까지 미리 로딩하기 때문에 메모리 사용량이 증가하고 성능에 영향을 줄 수 있음
- **사용 시나리오**: 항상 함께 사용되는 연관 관계에 적합

### 1. JPA 로딩 전략 및 N+1 문제 발생 여부

| 로딩 전략     | 단일 값 연관 관계 (Many-to-One, One-to-One) | 컬렉션 타입 연관 관계 (One-to-Many, Many-to-Many) | N+1 문제 발생 여부      |
| --------- | ------------------------------------ | ---------------------------------------- | ----------------- |
| **지연 로딩** | 기본적으로 해당 엔티티가 참조될 때까지 로딩되지 않음        | 컬렉션의 개별 요소에 접근할 때마다 쿼리 발생                | 발생 가능             |
| **즉시 로딩** | 엔티티 조회 시 즉시 로딩                       | 부모 엔티티 조회 시 컬렉션도 함께 로딩하려고 시도             | 발생 가능 (상황에 따라 다름) |

### 2. 즉시 로딩에서 컬렉션 타입의 N+1 문제 발생 여부

|조건|발생 여부|설명|
|---|---|---|
|**즉시 로딩 + 단일 값 연관 관계**|**발생 안함**|단일 값 연관 관계 (예: `@ManyToOne`, `@OneToOne`)에서는 즉시 로딩 시 한 번의 조인 쿼리로 데이터를 가져옵니다.|
|**즉시 로딩 + 컬렉션 타입 (One-to-Many, Many-to-Many)**|**상황에 따라 발생**|즉시 로딩이더라도, JPA는 컬렉션 타입을 효율적으로 한 번에 로딩하지 못할 경우 N+1 문제가 발생할 수 있습니다.|

### 3. 컬렉션 타입에서 즉시 로딩의 N+1 문제 발생 예시

| 상황                                           | 쿼리 실행 횟수 예시                        | N+1 문제 발생 여부 |
| -------------------------------------------- | ---------------------------------- | ------------ |
| **Order 엔티티 10개 조회 + OrderItem 컬렉션 (즉시 로딩)** | 1번 `Order` 쿼리 + 10번 `OrderItem` 쿼리 | 발생           |
| **Order 엔티티 10개 조회 + OrderItem 컬렉션 (페치 조인)** | 1번 `Order` + `OrderItem` 조인 쿼리 1번  | 발생 안함        |
| **Order 엔티티 1개 조회 + OrderItem 컬렉션 (즉시 로딩)**  | 1번 `Order` + 1번 `OrderItem` 쿼리     | 발생 안함        |

### 결론

- **즉시 로딩**을 사용하더라도 컬렉션 타입의 연관 관계에서 항상 N+1 문제가 발생하는 것은 아닙니다. 하지만, 많은 부모 엔티티를 한 번에 조회하는 상황에서 컬렉션을 즉시 로딩할 경우, JPA가 각 컬렉션 항목을 별도의 쿼리로 가져오게 되면서 N+1 문제가 발생할 수 있습니다.
- **단일 값 연관 관계**에서는 즉시 로딩이 N+1 문제를 유발하지 않습니다. 이는 한 번의 조인 쿼리로 필요한 모든 데이터를 가져올 수 있기 때문입니다.
- **페치 조인**을 사용하면 이러한 문제를 방지하고, 한 번의 쿼리로 모든 관련 데이터를 효율적으로 가져올 수 있습니다.


## 2. 영속성 관리

### 2.1 더티 체킹 (Dirty Checking)

- **정의**: 엔티티의 상태가 변경되었을 때 트랜잭션이 커밋될 때 자동으로 변경 사항을 데이터베이스에 반영하는 기능
- **작동 방식**: 영속성 컨텍스트는 엔티티의 원본 상태를 저장하고 엔티티의 현재 상태와 비교하여 변경 사항이 있는 경우 자동으로 UPDATE 쿼리를 생성
- **장점**: 개발자가 명시적으로 update 메서드를 호출하지 않아도 되어 편리함

### 2.2 1차 캐시

- **정의**: 영속성 컨텍스트 내에서 엔티티를 조회하거나 저장할 때 해당 엔티티를 캐시하여 동일한 트랜잭션 내에서 데이터베이스에 반복적으로 접근하는 것을 방지하는 기능
- **장점**: 동일한 엔티티에 대한 중복된 데이터베이스 접근을 줄여 성능을 최적화
- **단점**: 큰 트랜잭션에서 메모리 사용량이 증가할 수 있음

### 2.3 영속성 컨텍스트

- **정의**: 엔티티 매니저가 관리하는 엔티티 객체들이 저장되는 공간
- **역할**:
    1. 엔티티를 영속성 컨텍스트에 저장하여 1차 캐시를 제공
    2. 엔티티의 변경 감지를 통해 더티 체킹을 수행
    3. 트랜잭션이 끝날 때 변경 사항을 데이터베이스에 반영
- **장점**: 엔티티의 생명주기를 효율적으로 관리하여 데이터베이스 작업을 최적화

## 3. 연관 관계

### 3.1 1대N 연관관계

- **정의**: 한 엔티티가 여러 엔티티와 연관된 관계
- **예시**: Order와 OrderItem 관계에서 한 Order가 여러 OrderItem을 가질 수 있음

### 3.2 N대1 연관관계

- **정의**: 여러 엔티티가 하나의 엔티티와 연관된 관계
- **예시**: 여러 OrderItem이 하나의 Order에 속할 수 있음

### 3.3 N대N 연관관계

- **정의**: 여러 엔티티가 여러 엔티티와 연관된 관계
- **예시**: Student와 Course 사이의 관계는 다대다 관계
- **주의사항**: 실제 구현 시 중간 테이블을 사용하여 두 개의 1대N 관계로 구현하는 것이 일반적

### 3.4 1대1 연관관계

- **정의**: 한 엔티티가 다른 한 엔티티와 연관된 관계
- **예시**: User와 Profile 사이의 관계는 일대일 관계


### 3.5.1 양방향 예시 (1:N, N:1)

``` JAVA
@Entity
public class Team {

  

    @Id @GeneratedValue
    private Long id;

  

    private String name;

  

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();

}

  

@Entity
public class Member {

  

    @Id @GeneratedValue

    private Long id;

  

    private String name;

  

    @ManyToOne
    @JoinColumn(name = "team_id") // N:1 쪽에서 외래 키 관리
    private Team team;

}
```

**Member** **엔티티**:
	• @ManyToOne 관계를 사용하여 Team 엔티티와의 N:1 관계를 정의했습니다.
	• 이 설정은 Member 엔티티가 외래 키(team_id)를 통해 Team 엔티티를 참조하도록 만듭니다.

**Team** **엔티티**:
	• @OneToMany(mappedBy = "team")를 사용하여 Member 엔티티와의 1:N 관계를 정의했습니다.
	• mappedBy = "team"는 이 관계가 Member 엔티티의 team 필드에 의해 매핑된다는 것을 의미합니다. 
	• 즉, Team 엔티티는 members 리스트를 통해 자신에게 속한 Member들을 참조할 수 있습니다.

  
**양방향 관계의 정의**
	양방향 연관 관계란 **두 엔티티가 서로를 참조할 수 있는 관계**를 의미합니다. 

• Member 엔티티에서 Team을 참조할 수 있습니다.
• Team 엔티티에서 members 리스트를 통해 여러 Member들을 참조할 수 있습니다.

따라서, 이 예제는 양방향 관계로 설정된 것입니다.

  

**mappedBy의 역할**

• **mappedBy**는 JPA에서 양방향 관계를 설정할 때 사용됩니다. 이 속성은 **양방향 관계에서 외래 키를 관리하는 주체가 어느 쪽인지를 명시**하는 역할을 합니다.

• mappedBy = "team"을 Team 엔티티의 members 필드에 설정함으로써, 이 연관 관계의 주체(외래 키를 관리하는 주체)는 Member 엔티티의 team 필드임을 나타냅니다.

• 따라서, @OneToMany 쪽에서는 외래 키를 직접 관리하지 않고, **외래 키는** **Member** **엔티티 쪽에서 관리**됩니다.

  

**결론**

• **양방향 관계**: 두 엔티티(Team과 Member)가 서로를 참조할 수 있기 때문에, 이 예제는 양방향 연관 관계로 설정된 것입니다.

• **mappedBy****의 의미**: Team 엔티티 쪽에서 mappedBy를 사용함으로써, 외래 키 관리의 주체가 Member 엔티티 쪽에 있음을 명시했지만, 여전히 두 엔티티는 서로를 참조할 수 있으므로 양방향 관계로 간주됩니다.


### 3.5.2 단방향으로 변경 (N:1)

어떤 유튜버의 연관관계 사용 지침 (절대적인 정답이 아님을 주의)
https://www.youtube.com/watch?v=vgNHW_nb2mg&t=2s

걸지 않는 경우
- ﻿﻿양방향
- ﻿﻿단방향도 OneToMany 잘 안건다
- ﻿﻿OneToOne 안건다

거는 지침
- ﻿﻿라이프사이클(생명주기) 가 완전히 같다면 단방향만 ' 고민 ' 합니다
- ﻿﻿고민 후 단방향 ManyToOne 을 보통 건다

상당히 심오한 주제였음... 어둠의 다크니스

이를 반영해본다면 ?

```JAVA

@Entity
public class Team {

    @Id @GeneratedValue
    private Long id;

    private String name;

    // @OneToMany 제거: 단방향 관계로 변경하므로 이 부분을 제거합니다.
    // private List<Member> members = new ArrayList<>();
}

@Entity
public class Member {

    @Id @GeneratedValue
    private Long id;

    private String name;

    @ManyToOne
    @JoinColumn(name = "team_id") // 단방향 ManyToOne 관계로 유지
    private Team team;
}
```

더 나아가서 어쩌면 team 이 아니라, team_id를 가질 수도 있다.
멤버가 팀이 없을 수도 있지 않을까?

**외래키를 직접 가지는 상황에 대한 질문과 좋은 답변**
https://www.inflearn.com/community/questions/747142/jpa-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A0%A8%ED%95%98%EC%97%AC-%EC%A7%88%EB%AC%B8-%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4


**양방향을 미워하는 이유**
양방향 매핑은 단순히 데이터베이스의 값을 조회하여 객체 그래프 탐색 기능이 추가된 것이다. 
**주인이 아닌 곳에서 엔티티를 추가해도 데이터베이스에는 절대 반영되지 않는다.**

또한 순수한 객체를 고려하여 양뱡향 매핑을 설정할 때는 엔티티를 통해 외래키를 추가하거나 수정하는 부분에서 주인이 아닌 엔티티까지 고려하여 처리해야 한다. -> 그래서 안쓰나보다. 귀찮아보이긴한다.

아래는 자세한 설명!
https://hyeonic.tistory.com/224



### 3.6 심화

1. **양방향 연관 관계를 피하는 이유**:

• **복잡성 증가**: 양방향 연관 관계를 설정하면 양쪽의 데이터를 일관되게 유지하기 위해 많은 코드를 추가해야 합니다. 특히, 양방향 관계에서 관계를 업데이트할 때, 한쪽에서 변경된 내용을 다른 쪽에도 반영해야 하며, 이러한 과정에서 실수나 버그가 발생할 가능성이 높아집니다.

• **N+1 문제**: 양방향 관계를 설정하면, 잘못된 쿼리 설계로 인해 N+1 문제가 발생할 가능성이 큽니다. 이는 성능 저하로 이어질 수 있습니다.

• **테스트와 유지보수의 어려움**: 양방향 관계는 테스트 코드 작성과 유지보수를 복잡하게 만듭니다. 관계를 설정하고 유지하는 데 많은 리소스가 필요할 수 있습니다.

2. **단방향 연관 관계를 선호하는 이유**:

• **단순성과 명료성**: 단방향 연관 관계는 설정이 단순하고 이해하기 쉽습니다. 한쪽에서만 관계를 관리하면 되므로, 코드가 직관적이고 복잡성이 줄어듭니다.

• **효율적인 쿼리**: 단방향 관계는 쿼리를 작성할 때 더 명확하고 효율적인 SQL이 생성됩니다. 필요한 경우에만 데이터를 조회할 수 있으며, 불필요한 데이터 로딩을 방지할 수 있습니다.

3. **@OneToMany****를 잘 사용하지 않는 이유**:

• **비효율적인 데이터 접근**: 단방향 @OneToMany 관계에서는 데이터베이스에 외래 키가 설정되지 않기 때문에, JPA는 조인 테이블을 생성하거나, 컬렉션을 조회하기 위해 복잡한 쿼리를 생성하게 됩니다. 이는 성능 저하로 이어질 수 있습니다.

• **데이터 무결성 유지의 어려움**: @OneToMany 관계를 제대로 관리하지 않으면, 데이터 무결성 문제를 야기할 수 있습니다. 특히, 관계를 업데이트할 때 일관성을 유지하는 것이 어려울 수 있습니다.

4. **@OneToOne****을 피하는 이유**:

• **낮은 효율성**: @OneToOne 관계는 실제로 데이터베이스 설계에서 자주 사용되지 않으며, 효율적이지 않은 경우가 많습니다. 양방향 @OneToOne 관계는 관리가 복잡할 수 있으며, 이를 유지하는 것이 비효율적일 수 있습니다.

• **관계의 강제성**: @OneToOne 관계는 두 엔티티 간의 관계를 강하게 연결하며, 둘 중 하나라도 존재하지 않으면 관계가 성립되지 않습니다. 이는 설계의 유연성을 제한할 수 있습니다.

5. **라이프사이클이 일치하는 경우에만 고민**:

• **라이프사이클 동기화의 중요성**: 두 엔티티 간의 라이프사이클이 완전히 일치할 때만 연관 관계를 고려하는 이유는, 이를 통해 관계를 관리하는 복잡성을 줄일 수 있기 때문입니다. 예를 들어, 부모-자식 관계에서 부모가 삭제될 때 자식도 함께 삭제되도록 설정하는 경우가 이에 해당합니다.

• **단방향** **@ManyToOne** **선호**: 라이프사이클이 일치하더라도, 단방향 @ManyToOne 관계를 사용하는 이유는 관계를 단순화하고, 성능 및 유지보수성을 높이기 위해서입니다.

  

**결론**

  

이 사람은 JPA의 연관 관계 설정에서 **복잡성, 성능 문제, 유지보수의 어려움**을 고려하여 연관 관계를 최대한 단순화하려는 접근 방식을 취하고 있습니다. 특히, **단방향 연관 관계**를 선호하고, **양방향 관계를 피하는 이유**는 관계를 단순하고 명확하게 유지하면서도, 성능과 유지보수성을 최적화하려는 의도입니다.

  

이 접근 방식은 매우 실용적이며, 대규모 애플리케이션에서 성능과 유지보수를 쉽게 하려는 목적에서 비롯된 것으로 보입니다. 연관 관계를 설정할 때, 불필요한 복잡성을 줄이고, 성능 문제를 예방하려는 개발자들의 관점에서 이러한 지침은 매우 유효할 수 있습니다.

  

그러나, 특정 상황에서는 양방향 연관 관계나 @OneToMany, @OneToOne이 필요한 경우도 있을 수 있으므로, 이러한 지침은 **상황에 맞게 유연하게 적용**하는 것이 중요합니다.


## 4. 성능 최적화 기법

### 4.1 페치 조인 (Fetch Join)

- **정의**: 연관된 엔티티를 함께 조회하기 위해 사용하는 조인 방식
- **장점**: 한 번의 쿼리로 여러 연관된 엔티티를 함께 로드할 수 있어 N+1 문제를 방지
- **단점**: 너무 많은 연관 엔티티를 페치 조인하면 데이터 중복과 성능 저하를 일으킬 수 있음
- **사용 시나리오**: 특정 엔티티와 그 연관 엔티티를 자주 함께 조회하는 경우

### 4.2 N+1 문제

- **정의**: 하나의 쿼리로 N개의 엔티티를 조회하고 각 엔티티에 연관된 데이터를 가져오기 위해 추가로 N번의 쿼리가 실행되는 상황
- **해결 방법**:
    1. 페치 조인 사용
    2. 배치 사이즈 설정
    3. EntityGraph 사용
    4. DTO로 직접 조회

### 4.3 Batch Fetching

- **정의**: 한 번의 쿼리로 여러 연관된 엔티티를 일괄로 가져오는 방식
- **사용 이유**: 지연 로딩과 함께 사용하여 N+1 문제를 완화하기 위해 사용
- **설정 방법**: @BatchSize 어노테이션 또는 hibernate.default_batch_fetch_size 속성 사용

## 5. 추가 개념

### 5.1 영속성 전이 (Cascade)

- **정의**: 엔티티의 상태 변화가 연관된 다른 엔티티에도 전이되도록 하는 기능
- **예시**: 부모 엔티티를 삭제할 때 자식 엔티티도 함께 삭제하는 경우 CascadeType.ALL 설정
- **주의사항**: 남용 시 예상치 못한 부작용이 발생할 수 있으므로 신중하게 사용해야 함

### 5.2 고아 객체 (Orphan Removal)

- **정의**: 부모 엔티티에서 제거된 자식 엔티티를 자동으로 삭제하는 기능
- **예시**: 부모 엔티티에서 자식 엔티티를 제거하면 자식 엔티티도 삭제되도록 orphanRemoval = true 설정
- **사용 시나리오**: 부모-자식 관계에서 자식의 생명주기가 부모에 완전히 종속적인 경우

### 5.3 식별자 생성 전략 (GenerationType)

- **정의**: 데이터베이스에서 기본 키를 생성하는 방법을 지정하는 전략
- **종류**: AUTO, IDENTITY, SEQUENCE, TABLE
- **선택 기준**: 데이터베이스의 특성과 애플리케이션의 요구사항에 따라 선택

### 5.4 JPQL (Java Persistence Query Language)

- **정의**: JPA에서 사용하는 객체지향 쿼리 언어로 데이터베이스의 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성
- **특징**: SQL과 유사하지만 엔티티 객체를 대상으로 쿼리하므로 더 객체지향적임
- **장점**: 데이터베이스에 독립적인 쿼리 작성 가능

### 5.5 엔티티 생명주기 (Entity Life Cycle)

- **정의**: 엔티티가 영속성 컨텍스트에서 가지는 상태 변화 과정을 의미
- **상태**:
    1. Transient (비영속): 데이터베이스와 연결되지 않은 상태
    2. Persistent (영속): 영속성 컨텍스트에 의해 관리되는 상태
    3. Detached (준영속): 영속성 컨텍스트에서 분리된 상태
    4. Removed (삭제): 데이터베이스에서 삭제된 상태

### 5.6 Locking Mechanisms

- **정의**: 동시에 여러 트랜잭션이 같은 데이터를 수정하지 못하게 하는 동시성 제어 메커니즘
- **종류**:
    1. Optimistic Locking: 데이터가 변경되지 않았다고 가정하고 트랜잭션 커밋 시점에 충돌을 감지
    2. Pessimistic Locking: 데이터에 대한 수정이 발생하지 않도록 잠금을 걸어 다른 트랜잭션이 수정하지 못하도록 함
- **선택 기준**: 애플리케이션의 동시성 요구사항과 성능 고려사항에 따라 선택